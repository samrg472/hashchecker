use crate::{util, Report};
use std::{
    collections::HashMap,
    fs::File,
    io::{ErrorKind, Read, Write},
    path::{Path, PathBuf},
    sync::Arc,
    sync::Mutex,
};
use termcolor::{Color, ColorSpec, StandardStream, WriteColor};
use xml::reader::XmlEvent;

pub struct ArchiveOrgConf {
    pub stdout: Arc<Mutex<StandardStream>>,
    pub metadata_loc: String,
    pub files_path: PathBuf,
}

impl ArchiveOrgConf {
    pub async fn start(&self) {
        let xml_contents = retrieve_xml(&self.metadata_loc).await;

        let reader = xml::ParserConfig::new()
            .trim_whitespace(true)
            .create_reader(xml_contents.as_bytes());
        let metadata = parse_xml(reader);
        assert_eq!(
            metadata.name, "files",
            "invalid archive.org xml root element"
        );

        let mut latest_report = Report::default();

        for file in metadata.children {
            assert_eq!(file.name, "file", "expected file element");
            let format = file.get_child("format").unwrap();
            if format.value.as_ref().unwrap() == "Metadata"
                || file.attributes.get("source").unwrap() == "metadata"
            {
                // Ignore metadata generated by archive.org as they have no relevancy during
                // checks
                continue;
            }

            let name = file.get_attrib("name").unwrap();
            let exp_sha1 = file.get_child("sha1").unwrap().value.as_ref().unwrap();
            let mut exp_digest = vec![0u8; exp_sha1.len() / 2];
            faster_hex::hex_decode(exp_sha1.as_bytes(), &mut exp_digest).unwrap();
            let file_path = Path::join(&self.files_path, name);
            let report = self.check_file(name, file_path.clone(), exp_digest.clone());
            latest_report += report;
        }

        let mut stdout = self.stdout.lock().unwrap();
        write!(&mut stdout, "\n").unwrap();
        writeln!(&mut stdout, "SUMMARY:").unwrap();
        writeln!(&mut stdout, "    Passed files: {}", latest_report.passed).unwrap();
        writeln!(&mut stdout, "    Failed files: {}", latest_report.failed).unwrap();
        writeln!(&mut stdout, "    Missing files: {}", latest_report.missing).unwrap();
        writeln!(&mut stdout, "    Total checks: {}", latest_report.total()).unwrap();
    }

    fn check_file(&self, name: &str, file_path: PathBuf, exp_digest: Vec<u8>) -> Report {
        let mut stdout = self.stdout.lock().unwrap();
        let mut report = Report::default();

        let mut file = match File::open(&file_path) {
            Ok(file) => file,
            Err(e) => {
                match e.kind() {
                    ErrorKind::NotFound => {
                        report.missing += 1;
                        stdout
                            .set_color(ColorSpec::new().set_fg(Some(Color::Red)))
                            .unwrap();
                        write!(stdout, "MISSING").unwrap();
                        stdout.reset().unwrap();
                        writeln!(stdout, " ... {}", name).unwrap();
                    }
                    _ => {
                        writeln!(
                            stdout,
                            "Failed to open file at `{:?}` with error {:?}",
                            file_path, e
                        )
                        .unwrap();
                    }
                }
                return report;
            }
        };

        let actual_digest = hash_file!(file);

        if actual_digest.as_slice() == exp_digest {
            report.passed += 1;
            stdout
                .set_color(ColorSpec::new().set_fg(Some(Color::Green)))
                .unwrap();
            write!(stdout, "PASSED").unwrap();
            stdout.reset().unwrap();
            writeln!(stdout, "  ... {}", name).unwrap();
        } else {
            report.failed += 1;
            stdout
                .set_color(ColorSpec::new().set_fg(Some(Color::Red)))
                .unwrap();
            write!(stdout, "FAILED").unwrap();
            stdout.reset().unwrap();
            writeln!(stdout, "  ... {}", name).unwrap();
        }

        report
    }
}

fn parse_xml<R>(mut reader: xml::EventReader<R>) -> XmlDoc
where
    R: Read,
{
    loop {
        let data = reader.next().unwrap();
        match data {
            XmlEvent::StartDocument { .. } => {}
            XmlEvent::StartElement {
                name, attributes, ..
            } => {
                let attributes = {
                    let mut map = HashMap::new();
                    for attrib in attributes {
                        map.insert(attrib.name.local_name, attrib.value);
                    }
                    map
                };

                let mut parent = XmlDoc::new(name.local_name, attributes);
                parse_children(&mut reader, &mut parent);
                break parent;
            }
            _ => panic!("Unhandled event: {:?}", data),
        }
    }
}

fn parse_children<R>(reader: &mut xml::EventReader<R>, parent: &mut XmlDoc)
where
    R: Read,
{
    loop {
        let data = reader.next();
        match data {
            Ok(data) => match data {
                XmlEvent::StartElement {
                    name, attributes, ..
                } => {
                    let attributes = {
                        let mut map = HashMap::new();
                        for attrib in attributes {
                            map.insert(attrib.name.local_name, attrib.value);
                        }
                        map
                    };
                    let mut child = XmlDoc::new(name.local_name, attributes);
                    parse_children(reader, &mut child);
                    parent.children.push(child);
                }
                XmlEvent::Characters(data) => {
                    parent.value = Some(data);
                }
                XmlEvent::EndElement { .. } => {
                    break;
                }
                _ => panic!("Unhandled event: {:?}", data),
            },
            Err(e) => {
                panic!("Unable to parse xml: {}", e);
            }
        }
    }
}

async fn retrieve_xml(loc: &str) -> String {
    if Path::is_file(&PathBuf::from(loc)) {
        let mut file = std::fs::File::open(loc).expect("Failed to open metadata file");
        let mut contents = String::new();
        file.read_to_string(&mut contents)
            .expect("Failed to read XML");
        return contents;
    }

    let res = reqwest::get(loc).await.unwrap();
    res.text().await.unwrap()
}

#[derive(Debug)]
struct XmlDoc {
    name: String,
    value: Option<String>,
    attributes: HashMap<String, String>,
    children: Vec<XmlDoc>,
}

impl XmlDoc {
    pub fn new(name: String, attributes: HashMap<String, String>) -> Self {
        Self {
            name,
            value: None,
            attributes,
            children: Vec::new(),
        }
    }

    pub fn get_attrib(&self, name: &str) -> Option<&String> {
        self.attributes.get(name)
    }

    pub fn get_child(&self, name: &str) -> Option<&XmlDoc> {
        self.children.iter().find(|c| c.name == name)
    }
}
