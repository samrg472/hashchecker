use crate::{util, Report};
use rru_common::XmlDoc;
use std::{
    fs::File,
    io::{ErrorKind, Read, Write},
    path::{Path, PathBuf},
    sync::Arc,
    sync::Mutex,
};
use termcolor::{Color, ColorSpec, StandardStream, WriteColor};

pub struct ArchiveOrgConf {
    pub stdout: Arc<Mutex<StandardStream>>,
    pub metadata_loc: String,
    pub files_path: PathBuf,
}

impl ArchiveOrgConf {
    pub async fn start(&self) {
        let xml_doc = retrieve_xml(&self.metadata_loc).await;
        let metadata = XmlDoc::parse(&xml_doc);

        assert_eq!(
            metadata.name(),
            "files",
            "invalid archive.org xml root element"
        );

        let mut latest_report = Report::default();

        for file in metadata.children() {
            assert_eq!(file.name(), "file", "expected file element");
            let format = file.get_child("format").unwrap();
            if format.value().unwrap() == "Metadata"
                || file.get_attrib("source").unwrap() == "metadata"
            {
                // Ignore metadata generated by archive.org as they have no relevancy during
                // checks
                continue;
            }

            let name = file.get_attrib("name").unwrap();
            let exp_sha1 = file.get_child("sha1").unwrap().value().unwrap();
            let mut exp_digest = vec![0u8; exp_sha1.len() / 2];
            faster_hex::hex_decode(exp_sha1.as_bytes(), &mut exp_digest).unwrap();
            let file_path = Path::join(&self.files_path, name);
            let report = self.check_file(name, file_path, exp_digest.clone());
            latest_report += report;
        }

        let mut stdout = self.stdout.lock().unwrap();
        write!(&mut stdout, "\n").unwrap();
        writeln!(&mut stdout, "SUMMARY:").unwrap();
        writeln!(&mut stdout, "    Passed files: {}", latest_report.passed).unwrap();
        writeln!(&mut stdout, "    Failed files: {}", latest_report.failed).unwrap();
        writeln!(&mut stdout, "    Missing files: {}", latest_report.missing).unwrap();
        writeln!(&mut stdout, "    Total checks: {}", latest_report.total()).unwrap();
    }

    fn check_file(&self, name: &str, file_path: PathBuf, exp_digest: Vec<u8>) -> Report {
        let mut stdout = self.stdout.lock().unwrap();
        let mut report = Report::default();

        let mut file = match File::open(&file_path) {
            Ok(file) => file,
            Err(e) => {
                match e.kind() {
                    ErrorKind::NotFound => {
                        report.missing += 1;
                        stdout
                            .set_color(ColorSpec::new().set_fg(Some(Color::Red)))
                            .unwrap();
                        write!(stdout, "MISSING").unwrap();
                        stdout.reset().unwrap();
                        writeln!(stdout, " ... {}", name).unwrap();
                    }
                    _ => {
                        writeln!(
                            stdout,
                            "Failed to open file at `{:?}` with error {:?}",
                            file_path, e
                        )
                        .unwrap();
                    }
                }
                return report;
            }
        };

        let actual_digest = hash_file!(file);

        if actual_digest.as_slice() == exp_digest {
            report.passed += 1;
            stdout
                .set_color(ColorSpec::new().set_fg(Some(Color::Green)))
                .unwrap();
            write!(stdout, "PASSED").unwrap();
            stdout.reset().unwrap();
            writeln!(stdout, "  ... {}", name).unwrap();
        } else {
            report.failed += 1;
            stdout
                .set_color(ColorSpec::new().set_fg(Some(Color::Red)))
                .unwrap();
            write!(stdout, "FAILED").unwrap();
            stdout.reset().unwrap();
            writeln!(stdout, "  ... {}", name).unwrap();
        }

        report
    }
}

async fn retrieve_xml(loc: &str) -> String {
    if Path::is_file(&PathBuf::from(loc)) {
        let mut file = std::fs::File::open(loc).expect("Failed to open metadata file");
        let mut contents = String::new();
        file.read_to_string(&mut contents)
            .expect("Failed to read XML");
        return contents;
    }

    let res = reqwest::get(loc).await.unwrap();
    res.text().await.unwrap()
}
